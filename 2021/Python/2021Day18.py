# -*- coding: utf-8 -*-
"""
Created on Sat Dec 18 08:30:55 2021

@author: choes
"""

input = """[[[0,[4,5]],[0,0]],[[[4,5],[2,6]],[9,5]]]
[7,[[[3,7],[4,3]],[[6,3],[8,8]]]]
[[2,[[0,8],[3,4]]],[[[6,7],1],[7,[1,6]]]]
[[[[2,4],7],[6,[0,5]]],[[[6,8],[2,8]],[[2,1],[4,5]]]]
[7,[5,[[3,8],[1,4]]]]
[[2,[2,2]],[8,[8,1]]]
[2,9]
[1,[[[9,3],9],[[9,0],[0,7]]]]
[[[5,[7,4]],7],1]
[[[[4,2],2],6],[8,7]]"""


input = """[[[4,5],[[0,6],[4,5]]],[3,[[5,0],[0,8]]]]
[[8,3],2]
[[4,[7,[5,6]]],[[[7,8],5],[[7,0],1]]]
[[[1,8],[7,6]],[[8,6],[3,2]]]
[[[4,[2,0]],[1,[7,0]]],9]
[2,[[[2,3],5],[6,5]]]
[9,[1,[0,3]]]
[5,[5,[8,[8,4]]]]
[5,[1,[4,[0,8]]]]
[1,[[[6,1],9],2]]
[7,[[6,1],[[7,8],[4,2]]]]
[[[[6,6],[3,3]],[6,[7,6]]],4]
[[[3,[9,8]],[[6,6],[9,3]]],[[[9,2],3],[[7,6],0]]]
[[[[5,2],6],[9,[1,7]]],[[9,9],[9,[4,3]]]]
[[[7,6],[9,5]],[[[6,3],[8,4]],[[4,0],8]]]
[[[0,[1,9]],[8,[4,4]]],1]
[[1,[1,[9,4]]],[5,[[9,3],9]]]
[[[1,3],[[2,3],9]],[7,9]]
[[8,[[6,9],[5,9]]],[5,[5,[9,4]]]]
[[[[3,7],[8,0]],[4,[8,9]]],[[[3,8],[3,5]],[9,0]]]
[[[0,5],[5,1]],[3,[0,[0,5]]]]
[7,[[4,[1,6]],0]]
[[3,[4,4]],[[[0,5],9],[8,[9,5]]]]
[[8,[5,2]],[[[7,4],[3,2]],4]]
[[[[6,4],[7,9]],5],[3,[[4,3],[4,3]]]]
[[[[7,0],6],[6,7]],[[[9,7],[3,7]],[[4,1],[0,6]]]]
[[6,[[1,0],[1,7]]],[3,[3,0]]]
[[[2,[6,0]],4],[[3,9],[4,1]]]
[[[0,[8,4]],[[8,7],5]],[1,6]]
[[[[4,0],7],9],[6,[8,[9,3]]]]
[[[[0,8],7],[5,[4,0]]],[5,[6,[8,7]]]]
[[[1,4],[[9,7],4]],[[4,[6,4]],1]]
[[5,[[8,6],9]],1]
[[[[5,7],[8,3]],[[3,2],[1,9]]],[2,[1,2]]]
[[[9,6],[1,5]],[8,6]]
[3,1]
[[2,[[2,0],4]],[[[3,4],1],3]]
[[[[8,6],[5,9]],7],2]
[[[[1,0],[8,5]],[[6,5],[0,0]]],[[[3,4],[4,6]],[[5,0],8]]]
[[[[6,4],[9,4]],[[2,1],[2,2]]],[[[7,9],1],[[6,1],5]]]
[2,[[4,4],5]]
[[[[0,8],9],[8,6]],[[[9,7],[0,8]],[[9,3],7]]]
[[[[2,0],[7,8]],[[8,5],[6,8]]],[7,[[1,1],[2,3]]]]
[[9,[5,[4,7]]],[0,[9,2]]]
[5,[[[7,5],3],[6,[5,3]]]]
[[1,[5,1]],[[[0,3],[3,9]],3]]
[7,[[0,[0,1]],[1,2]]]
[[4,[8,0]],[3,[[2,4],7]]]
[8,[[1,[8,9]],[0,0]]]
[0,[[2,9],[[9,7],[5,3]]]]
[[[6,[3,4]],[[0,6],[4,3]]],9]
[[[[0,6],6],6],[[7,8],[[7,3],[5,0]]]]
[[[7,[4,5]],[9,2]],[6,[[5,5],[0,2]]]]
[[[6,8],[5,[0,8]]],[[1,[6,6]],[0,6]]]
[[[[4,7],7],[2,7]],[[8,0],[[6,5],[2,0]]]]
[8,[[4,9],[[8,8],2]]]
[2,[[4,[5,8]],[[8,7],[0,9]]]]
[[[[2,8],0],6],[[[4,4],0],[1,3]]]
[1,[[[8,5],1],8]]
[[3,3],[[[5,6],[6,2]],5]]
[[9,2],[3,[[3,2],4]]]
[[[[2,4],[6,3]],[[4,6],4]],[[[1,9],[0,4]],[[2,6],[9,0]]]]
[[[4,[6,7]],[[8,4],[6,2]]],[[5,2],[[4,8],0]]]
[[[6,0],[[3,2],5]],[[[9,0],[7,0]],5]]
[[2,[9,3]],[[4,[4,6]],[9,6]]]
[[3,[3,6]],[[[2,4],1],[9,[7,7]]]]
[4,[1,[[3,6],[4,1]]]]
[[3,7],[[5,6],6]]
[[[0,8],4],[[3,5],[[6,2],6]]]
[[[6,[8,9]],[5,[2,4]]],[4,[3,4]]]
[5,[[[6,8],[5,7]],[5,[9,9]]]]
[[[[9,5],6],3],[[[8,2],4],[1,8]]]
[[9,[9,3]],[[[5,7],0],[[5,4],[7,4]]]]
[[[[7,7],7],6],9]
[[9,8],[2,[7,7]]]
[[[[5,9],6],[8,[9,2]]],[[[8,5],[9,5]],[3,[8,3]]]]
[[[4,[3,8]],[8,[4,3]]],[[0,5],[5,[4,5]]]]
[[[0,5],[[7,7],5]],[[[2,7],[6,0]],[[7,9],[2,2]]]]
[6,[2,8]]
[[[2,7],7],[[[8,4],[3,9]],1]]
[[[2,0],[[0,5],[9,4]]],[[7,[6,2]],9]]
[[1,[[8,3],[3,4]]],1]
[[[[2,0],9],3],[1,[7,[2,1]]]]
[4,[[6,[5,7]],[[1,1],[0,5]]]]
[[[6,[0,7]],[4,[8,6]]],3]
[[[8,5],6],[1,[[6,0],4]]]
[[[[6,5],[5,6]],[[0,1],[2,7]]],[[7,[7,6]],[[3,2],[4,0]]]]
[[[5,[0,0]],0],5]
[[[[7,2],[5,9]],2],[3,7]]
[7,[[[1,1],4],[[4,4],2]]]
[9,[[[9,1],1],3]]
[[[[6,9],[3,9]],[7,[1,5]]],[[[5,0],6],[[5,9],8]]]
[[7,[1,[2,1]]],[7,[[6,3],[7,1]]]]
[3,[0,[1,3]]]
[9,[[[6,6],6],[6,4]]]
[[[2,[0,4]],1],[[9,[5,1]],[[9,6],[5,2]]]]
[[[9,8],6],[0,[6,[0,5]]]]
[[[7,3],[[9,9],0]],7]
[[[7,5],[6,8]],[6,[[0,8],9]]]
[[[2,[0,5]],[[2,9],[5,7]]],7]"""



import ast
import copy

snailInput = [ast.literal_eval(line) for line in input.split("\n")]


class Pair:    
    def __init__(self, value, parent = None):
        value = copy.deepcopy(value)
        if isinstance(value, int):
            self.type_ = "Number"
            self.number = value
            self.parent = parent
            return
        elif isinstance(value, Pair):                
            self.type_ = value.type_            
            self.parent = parent
            if self.type_ == "Number":
                self.number = value.number            
            else:                
                self.left = value.left
                self.left.parent = self
                self.right = value.right
                self.right.parent = self
            return
        else:            
            if len(value) != 2:
                raise ValueError("Invalid pair")
            self.type_ = "Pair"
            self.left = Pair(value[0], self)
            self.right = Pair(value[1], self)
            self.parent = parent

    def __str__(self):
        if self.type_ == "Number":
            return str(self.number)
        else:
            return f"[{str(self.left)}, {str(self.right)}]"

    def __repr__(self):
        return str(self)

    
    def __add__(self, other):
        newValue = Pair([self, other])
        newValue.reduce()
        return newValue


    def reduce(self):        
        if self.explode(0):
            self.reduce()
        elif self.split():
            self.reduce()
        else:
            return True

    
    def split(self):
        if self.type_ == "Number" and self.number <= 9:
            return False
        
        # Edge case where the whole tree is just a single large number
        if self.parent is None and self.type_ == "Number":
            if self.number > 9:
                leftNumber = self.number // 2
                rightNumber = self.number - leftNumber
                self = Pair([leftNumber, rightNumber], parent = None)
                return True
        
        if self.type_ == "Number" and self.number > 9:
            identity = "left" if self.parent.left == self else "right"
            leftNumber = self.number // 2
            rightNumber = self.number - leftNumber                
            if identity == "left":                
                self.parent.left = Pair([leftNumber, rightNumber], parent = self.parent)
            else:                
                self.parent.right= Pair([leftNumber, rightNumber], parent = self.parent)
            return True
        
        # In this case MUST be a pair
        if self.type_ == "Number":
            raise ValueError("Should be a pair")
        
        if self.left.split():
            return True
        else:
            return self.right.split()


    def explode(self, n):
        if self.type_ == "Number":
            return False
        
        # At this point _must_ be a pair
        if n > 4:
            raise ValueError("Should never get this deep")
            
        if n < 4:
            if self.left.explode(n+1):
                return True
            else:
                return self.right.explode(n+1)
        
        if n == 4:
            immediateParent = self.parent
            
            if self.right.type_ != "Number":
                raise ValueError("Level 4 but not a number")
            
            if self.left.type_ != "Number":
                raise ValueError("Level 4 but not a number")    
            
            identity = "left" if immediateParent.left == self else "right"
            
            rightNumber = self.right.number
            leftNumber = self.left.number            
            
            self._addToFirstRightNumberGoingUp(rightNumber)
            self._addToFirstLeftNumberGoingUp(leftNumber)
            
            if identity == "left":
                immediateParent.left = Pair(0, immediateParent)
            else:
                immediateParent.right = Pair(0, immediateParent)
            return True

                
    def _addToFirstRightNumberGoingUp(self, number):        
        thisParent = self.parent
        
        if thisParent is None:
            return
        
        if thisParent.right == self:
            thisParent._addToFirstRightNumberGoingUp(number)
        else:
            thisParent.right._addToFirstLeftNumberGoingDown(number)
            
            
    def _addToFirstLeftNumberGoingDown(self, number):
        if self.type_ == "Number":
            self.number += number
            return
        
        self.left._addToFirstLeftNumberGoingDown(number)


    def _addToFirstLeftNumberGoingUp(self, number):
        thisParent = self.parent
        
        if thisParent is None:
            return
                
        if thisParent.left != self:
            thisParent.left._addToFirstRightNumberGoingDown(number)
        else:
            thisParent._addToFirstLeftNumberGoingUp(number)
        
            
    def _addToFirstRightNumberGoingDown(self, number):
        if self.type_ == "Number":
            self.number += number
            return
        
        self.right._addToFirstRightNumberGoingDown(number)
        
    
    def magnitude(self):
        if self.type_ == "Number":
            return self.number
        else:
            return 3 * self.left.magnitude() + 2 * self.right.magnitude()
    

x = Pair([[[[4,3],4],4],[7,[[8,4],9]]]) + Pair( [1,1])

result = None

for i in range(len(snailInput)-1):
    if result is None:
        result = Pair(snailInput[0])
    new = (snailInput[i+1])    
    print(f"Adding together: \n    {result} + \n    {new} = ")
    result = result + new
    print(f"    ={result}")


potentialIndices = [(i, j) for i in range(len(snailInput)) for j in range(len(snailInput)) if i != j]

max = 0
count = 0

for i, j in potentialIndices:
    print(count)
    thisSum = Pair(snailInput[i]) + Pair(snailInput[j])
    thisMagnitude = thisSum.magnitude()
    if thisMagnitude > max:
        max = thisMagnitude
    count += 1 
